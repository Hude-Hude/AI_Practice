---
title: "Solving a Static Oligopoly Pricing Model"
subtitle: "Bertrand Competition with Differentiated Products"
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
---

## Instruction

**Goal**: Replicate the structure of `scripts/solve_mdp/solve_mdp.qmd`, but replace the Markov Decision Process with a **static oligopoly pricing model** in which multiple firms set prices simultaneously to maximize period profits. The objective is to design and document a solver that:

- Specifies firm demand (e.g., logit demand with market share as a function of own price and rivals' prices)
- Defines marginal costs and strategic interaction assumptions (Bertrand competition with differentiated products)
- Derives the Nash equilibrium first-order conditions for optimal prices
- Implements a numerical fixed-point or contraction mapping routine that solves for equilibrium prices and markups under the chosen demand system

**Required Components**:

1. **Model primitives**: Demand parameters, cost structure, number of firms/products, and any demand and cost shifters.
2. **Equilibrium algorithm**: Specify how to numerically solve the nonlinear system of first-order conditions (FOCs) characterizing the static Nash equilibrium in prices.
3. **Verification plan**: Outline how juniors should validate convergence (e.g., norm of FOC residuals, comparison to analytical benchmarks in symmetric cases).
4. **Documentation**: Describe expected figures/tables (e.g., comparative statics over demand elasticities, passthrough analyses) without implementing them.

**Deliverable**: An executable Quarto report and rendered html report that mirrors the MDP solver report while focusing entirely on the static oligopoly pricing equilibrium problem.

---

## Model Setup

We consider a static oligopoly pricing model with:

- **Products**: $J$ differentiated products indexed by $j = 1, \ldots, J$, plus an outside option $j = 0$
- **Firms**: $F$ firms, where firm $f$ owns a subset of products $\mathcal{J}_f \subseteq \{1, \ldots, J\}$
- **Market size**: Normalized to $M = 1$ (equilibrium prices are independent of market size)
- **Competition**: Bertrand (simultaneous price setting)

### Demand: Logit Model

Consumer $i$'s indirect utility from product $j$ is:
$$
u_{ij} = \delta_j - \alpha p_j + \varepsilon_{ij}
$$

where:

- $\delta_j$ = mean utility of product $j$ (captures quality, characteristics)
- $\alpha > 0$ = price sensitivity coefficient
- $p_j$ = price of product $j$
- $\varepsilon_{ij} \sim$ Type-I Extreme Value (iid across consumers and products)

The outside option provides utility $u_{i0} = \varepsilon_{i0}$ (normalized to zero mean utility).

### Market Shares

Under the logit assumption, the market share of product $j$ is:
$$
s_j(p) = \frac{\exp(\delta_j - \alpha p_j)}{1 + \sum_{k=1}^{J} \exp(\delta_k - \alpha p_k)}
$$

The outside option share is:
$$
s_0(p) = \frac{1}{1 + \sum_{k=1}^{J} \exp(\delta_k - \alpha p_k)}
$$

### Cost Structure

Each product $j$ has constant marginal cost $c_j$. Firm $f$'s profit is:
$$
\pi_f(p) = \sum_{j \in \mathcal{J}_f} (p_j - c_j) \cdot s_j(p)
$$

## Equilibrium Conditions

### Bertrand-Nash Equilibrium

In a Bertrand-Nash equilibrium, each firm $f$ chooses prices for its products to maximize profit, taking rivals' prices as given:
$$
\max_{\{p_j\}_{j \in \mathcal{J}_f}} \sum_{j \in \mathcal{J}_f} (p_j - c_j) \cdot s_j(p)
$$

### First-Order Conditions

The FOC for product $j$ owned by firm $f$ is:
$$
\frac{\partial \pi_f}{\partial p_j} = s_j + \sum_{k \in \mathcal{J}_f} (p_k - c_k) \cdot \frac{\partial s_k}{\partial p_j} = 0
$$

### Logit Share Derivatives

For the logit model, the share derivatives have closed-form expressions:

**Own-price effect** (negative):
$$
\frac{\partial s_j}{\partial p_j} = -\alpha s_j (1 - s_j)
$$

**Cross-price effect** (positive, for $k \neq j$):
$$
\frac{\partial s_k}{\partial p_j} = \alpha s_k s_j
$$

### Matrix Formulation

Define the following matrices:

- **Ownership matrix** $\Omega$: $\Omega_{jk} = 1$ if products $j$ and $k$ are owned by the same firm, $0$ otherwise
- **Share derivative matrix** $\Delta$: $\Delta_{jk} = -\frac{\partial s_j}{\partial p_k}$

For logit demand:
$$
\Delta_{jk} = \begin{cases}
\alpha s_j (1 - s_j) & \text{if } j = k \\
-\alpha s_j s_k & \text{if } j \neq k
\end{cases}
$$

### Markup Equation

The system of FOCs can be written compactly as:
$$
s - (\Omega \odot \Delta)(p - c) = 0
$$

where $\odot$ denotes element-wise (Hadamard) product.

Solving for the equilibrium markup:
$$
p - c = (\Omega \odot \Delta)^{-1} s
$$

This is the **markup equation**: equilibrium prices equal marginal cost plus a markup that depends on:

1. **Market shares** $s$ — higher shares imply more market power
2. **Price sensitivity** $\alpha$ — higher sensitivity reduces markups
3. **Ownership structure** $\Omega$ — multi-product firms internalize cannibalization

## Analytical Benchmarks

### Single-Product Firms

When each firm owns exactly one product ($\Omega = I$), the FOC for product $j$ simplifies to:
$$
s_j - \alpha s_j (1 - s_j) \eta_j = 0
$$

Solving for the markup:
$$
\eta_j = \frac{1}{\alpha (1 - s_j)}
$$

**Interpretation**: Markup is inversely proportional to:

- Price sensitivity $\alpha$
- "Competitive pressure" $(1 - s_j)$ = probability of losing customer to other products

### Symmetric Equilibrium

For identical products ($\delta_j = \delta$, $c_j = c$ for all $j$) with single-product firms, the symmetric equilibrium has $s_j = s$ for all $j$:
$$
s = \frac{\exp(\delta - \alpha p)}{1 + J \exp(\delta - \alpha p)}
$$

With markup $\eta = \frac{1}{\alpha(1-s)}$.

As $J \to \infty$: $s \to 0$, so $\eta \to \frac{1}{\alpha}$ (competitive limit).

### Comparative Statics

| Parameter | Change | Effect on Markup $\eta$ | Effect on Price $p$ | Intuition |
|-----------|--------|-------------------------|---------------------|-----------|
| $\alpha$ ↑ | More price sensitive | $\eta$ ↓ | $p$ ↓ | Elastic demand → less market power |
| $\delta_j$ ↑ | Higher quality | $\eta_j$ ↑ | $p_j$ ↑ | Higher $s_j$ → more inelastic residual demand |
| $c_j$ ↑ | Higher cost | — | $p_j$ ↑ | Cost pass-through |
| $J$ ↑ | More competitors | $\eta$ ↓ | $p$ ↓ | Lower shares → more competition |
| Merger | $\Omega_{jk}: 0 \to 1$ | $\eta_j, \eta_k$ ↑ | $p_j, p_k$ ↑ | Internalize cannibalization |

### Cost Pass-Through

For single-product firms with logit demand, the pass-through rate measures how much of a cost increase is passed to consumers:
$$
\rho_j = \frac{\partial p_j}{\partial c_j}
$$

Differentiating the equilibrium condition yields:
$$
\rho_j = \frac{1}{1 + \alpha s_j \eta_j}
$$

Substituting $\eta_j = \frac{1}{\alpha(1-s_j)}$:
$$
\rho_j = \frac{1}{1 + \frac{s_j}{1-s_j}} = 1 - s_j
$$

**Result**: Pass-through $\rho_j = 1 - s_j < 1$.

**Interpretation**:

- Firms with **higher market share** absorb more of cost increases ($\rho_j$ lower)
- Firms with **lower market share** pass through more to consumers ($\rho_j$ closer to 1)
- In the competitive limit ($s_j \to 0$): $\rho_j \to 1$ (full pass-through)

### Product Differentiation Scenarios

Products can be differentiated through the **demand side** (quality $\delta$) and/or **supply side** (cost $c$). Below we analyze different scenarios:

#### Scenario 1: Symmetric/Homogeneous Products (Baseline)

**Setup**: $\delta_j = \delta$ and $c_j = c$ for all $j$

| Parameter | Value |
|-----------|-------|
| Mean utility | $\delta_j = \delta$ (identical) |
| Marginal cost | $c_j = c$ (identical) |

**Equilibrium Properties**:

- All products have equal shares: $s_j = s = \frac{e^{\delta - \alpha p}}{1 + J e^{\delta - \alpha p}}$
- All products have equal markups: $\eta_j = \eta = \frac{1}{\alpha(1-s)}$
- All products have equal prices: $p_j = p = c + \eta$

**Use case**: Theoretical benchmarks, isolating effects of $\alpha$, $J$, or ownership changes.

---

#### Scenario 2: Quality Differentiation Only

**Setup**: $\delta_j$ varies, $c_j = c$ constant

| Parameter | Value |
|-----------|-------|
| Mean utility | $\delta_1 < \delta_2 < \delta_3$ (quality gradient) |
| Marginal cost | $c_j = c$ (identical) |

**Example**: Digital goods, software products (zero marginal cost, quality varies)

**Equilibrium Properties**:

- Higher quality → higher share: $\delta_j > \delta_k \Rightarrow s_j > s_k$
- Higher share → higher markup: $s_j > s_k \Rightarrow \eta_j > \eta_k$
- Higher quality → higher price: $\delta_j > \delta_k \Rightarrow p_j > p_k$

**Key insight**: Quality leaders charge higher prices despite identical costs because their higher market share gives them more market power.

---

#### Scenario 3: Cost Differentiation Only

**Setup**: $\delta_j = \delta$ constant, $c_j$ varies

| Parameter | Value |
|-----------|-------|
| Mean utility | $\delta_j = \delta$ (identical) |
| Marginal cost | $c_1 < c_2 < c_3$ (efficiency gradient) |

**Example**: Commodity markets with heterogeneous production efficiency

**Equilibrium Properties**:

- Lower cost → lower price: $c_j < c_k \Rightarrow p_j < p_k$
- Lower price → higher share: $p_j < p_k \Rightarrow s_j > s_k$
- Higher share → higher markup: $s_j > s_k \Rightarrow \eta_j > \eta_k$

**Key insight**: Cost-efficient firms gain market share, which increases their markup, partially offsetting the cost advantage in prices.

---

#### Scenario 4: Vertical Differentiation (Quality-Cost Correlation)

**Setup**: $\delta_j$ and $c_j$ positively correlated (higher quality costs more)

| Parameter | Value |
|-----------|-------|
| Mean utility | $\delta_1 < \delta_2 < \delta_3$ |
| Marginal cost | $c_1 < c_2 < c_3$ (correlated with $\delta$) |

**Example**: Economy vs. premium cars, budget vs. luxury hotels

**Equilibrium Properties**:

- Price ordering follows quality: $p_1 < p_2 < p_3$
- Share ordering depends on $(\delta_j - \alpha p_j)$: quality advantage vs. price disadvantage
- Markup ordering: generally $\eta_1 < \eta_2 < \eta_3$ if quality effect dominates

**Key insight**: Premium products charge higher prices due to both higher costs and higher markups. The price gap exceeds the cost gap.

---

#### Scenario 5: General Heterogeneous Products

**Setup**: $\delta_j$ and $c_j$ vary independently

| Parameter | Value |
|-----------|-------|
| Mean utility | $\delta_j$ varies (not ordered) |
| Marginal cost | $c_j$ varies (not correlated with $\delta$) |

**Example**: Diverse product markets with varied positioning

**Equilibrium Properties**:

- No simple ordering of prices, shares, or markups
- Products with high $\delta$ and low $c$ are "dominant" (high share, high profit)
- Products with low $\delta$ and high $c$ may exit or have minimal share

**Comparative statics** in this scenario:

| Product Type | $\delta$ | $c$ | Share | Markup | Price | Profit |
|--------------|----------|-----|-------|--------|-------|--------|
| Dominant | High | Low | High | High | Moderate | High |
| Premium | High | High | Moderate | High | High | Moderate |
| Value | Low | Low | Moderate | Low | Low | Low |
| Weak | Low | High | Low | Low | Moderate | Very Low |

---

#### Summary: Sources of Product Asymmetry

| Scenario | $\delta$ | $c$ | Key Driver of Price Differences |
|----------|----------|-----|--------------------------------|
| 1. Symmetric | Same | Same | None (benchmark) |
| 2. Quality only | Varies | Same | Markup differences (demand side) |
| 3. Cost only | Same | Varies | Cost differences (supply side) |
| 4. Vertical | Correlated | Correlated | Both (premium positioning) |
| 5. General | Independent | Independent | Complex interactions |

**Implementation note**: The current solver handles all scenarios—simply pass different `delta` and `costs` vectors. The comparative statics section below demonstrates Scenario 1 (symmetric baseline). Extended analysis with heterogeneous products is marked for future implementation.

## Solution Method

### Fixed-Point Iteration on Markups

The markup equation defines a fixed-point problem. Define the markup $\eta_j = p_j - c_j$. Given prices $p = c + \eta$, the equilibrium markup satisfies:
$$
\eta = (\Omega \odot \Delta(c + \eta))^{-1} s(c + \eta)
$$

This suggests the **fixed-point iteration**:
$$
\eta^{(k+1)} = (\Omega \odot \Delta(p^{(k)}))^{-1} s(p^{(k)})
$$
where $p^{(k)} = c + \eta^{(k)}$.

### Damped Iteration

For stability, we use **damping** (convex combination of old and new):
$$
\eta^{(k+1)} = (1 - \lambda) \eta^{(k)} + \lambda \left[ (\Omega \odot \Delta(p^{(k)}))^{-1} s(p^{(k)}) \right]
$$
where $\lambda \in (0, 1]$ is the damping factor. Smaller $\lambda$ improves stability at the cost of slower convergence.

### Convergence Criterion

Iterate until the markup change is small:
$$
\| \eta^{(k+1)} - \eta^{(k)} \|_\infty < \varepsilon
$$

### Type Definitions

```
TYPE DEFINITIONS
────────────────
Scalar      = Float                      # Single real number
Vector[J]   = Array[Float, J]            # 1D array of J floats
Matrix[J,J] = Array[Float, J, J]         # 2D array of shape (J, J)
```

### Algorithm

```
ALGORITHM: SOLVE_EQUILIBRIUM_PRICES
───────────────────────────────────
INPUT:
  δ            : Vector[J]       # Mean utilities
  α            : Scalar          # Price sensitivity
  c            : Vector[J]       # Marginal costs
  Ω            : Matrix[J,J]     # Ownership matrix
  λ            : Scalar          # Damping factor (default: 1.0)
  ε            : Scalar          # Convergence tolerance
  K            : Int             # Maximum iterations

OUTPUT:
  p            : Vector[J]       # Equilibrium prices
  η            : Vector[J]       # Equilibrium markups
  s            : Vector[J]       # Equilibrium market shares
  converged    : Bool            # Convergence flag

PROCEDURE:
  # Initialize markups (start from marginal cost pricing)
  η : Vector[J] ← zeros(J)
  
  FOR k = 1 TO K:
    # Current prices
    p : Vector[J] ← c + η
    
    # Compute market shares
    s : Vector[J] ← COMPUTE_SHARES(δ, α, p)
    
    # Compute share derivative matrix
    Δ : Matrix[J,J] ← COMPUTE_DELTA(α, s)
    
    # Compute new markups from FOC
    η_new : Vector[J] ← SOLVE_MARKUP_EQUATION(Ω, Δ, s)
    
    # Damped update
    η_update : Vector[J] ← (1 - λ) * η + λ * η_new
    
    # Check convergence
    IF max(|η_update - η|) < ε:
      η ← η_update
      p ← c + η
      s ← COMPUTE_SHARES(δ, α, p)
      RETURN (p, η, s, converged=True)
    
    η ← η_update
  
  # Did not converge
  p ← c + η
  s ← COMPUTE_SHARES(δ, α, p)
  RETURN (p, η, s, converged=False)
```

### Subroutines

```
SUBROUTINE: COMPUTE_SHARES
──────────────────────────
INPUT:
  δ      : Vector[J]             # Mean utilities
  α      : Scalar                # Price sensitivity
  p      : Vector[J]             # Prices
OUTPUT:
  s      : Vector[J]             # Market shares

  # Compute mean utilities net of price
  v : Vector[J] ← δ - α * p
  
  # Numerically stable softmax
  v_max : Scalar ← max(v)
  exp_v : Vector[J] ← exp(v - v_max)
  denom : Scalar ← exp(-v_max) + sum(exp_v)
  
  s : Vector[J] ← exp_v / denom
  RETURN s
```

```
SUBROUTINE: COMPUTE_DELTA
─────────────────────────
INPUT:
  α      : Scalar                # Price sensitivity
  s      : Vector[J]             # Market shares
OUTPUT:
  Δ      : Matrix[J,J]           # Share derivative matrix

  # Δ_jk = -∂s_j/∂p_k
  FOR j = 1 TO J:
    FOR k = 1 TO J:
      IF j = k:
        Δ[j,k] ← α * s[j] * (1 - s[j])    # Own-price
      ELSE:
        Δ[j,k] ← -α * s[j] * s[k]          # Cross-price
  
  RETURN Δ
```

```
SUBROUTINE: SOLVE_MARKUP_EQUATION
─────────────────────────────────
INPUT:
  Ω      : Matrix[J,J]           # Ownership matrix
  Δ      : Matrix[J,J]           # Share derivative matrix
  s      : Vector[J]             # Market shares
OUTPUT:
  η      : Vector[J]             # Markups

  # Compute Ω ⊙ Δ (element-wise product)
  A : Matrix[J,J] ← Ω ⊙ Δ
  
  # Solve linear system: A * η = s
  η : Vector[J] ← SOLVE_LINEAR_SYSTEM(A, s)
  
  RETURN η
```

### Convergence Properties

The fixed-point iteration converges when the mapping is a **contraction**. Key factors affecting convergence:

1. **Price sensitivity $\alpha$**: Higher $\alpha$ → more elastic demand → smaller markups → faster convergence
2. **Market concentration**: More products owned by same firm → larger markups → slower convergence
3. **Damping $\lambda$**: Smaller $\lambda$ → more stable but slower

### Verification Plan

To validate the solver:

1. **FOC residuals**: Check $\| s + (\Omega \odot \Delta)(p - c) \|_\infty < \varepsilon$
2. **Symmetric benchmark**: For symmetric products with single-product firms, verify $\eta_j = \frac{1}{\alpha(1 - s_j)}$
3. **Monopoly benchmark**: Single firm owning all products should yield monopoly prices
4. **Comparative statics**: Higher $\alpha$ → lower markups; merger (change $\Omega$) → higher markups

## Implementation

### Setup

```{python}
#| label: setup
#| cache: false

# Standard libraries
import sys
import numpy as np
import matplotlib.pyplot as plt

# Add project paths
sys.path.insert(0, "../../../src")
sys.path.insert(0, "../config_opm")
sys.path.insert(0, "../../utils")

# Import OPM solver
from opm.solver_opm import (
    solve_equilibrium_prices,
    compute_shares,
    compute_delta,
    EquilibriumResult,
)

# Import configuration
import config

# Plot style
plt.style.use('seaborn-v0_8-whitegrid')
plt.rcParams['figure.figsize'] = (10, 6)
plt.rcParams['font.size'] = 11
plt.rcParams['axes.titlesize'] = 14
plt.rcParams['axes.labelsize'] = 12

print("Modules loaded successfully")
```

### Model Parameters

```{python}
#| label: parameters

# Load parameters from config (DRY principle)
J = config.J
delta = config.delta
alpha = config.alpha
costs = config.costs
ownership = config.ownership
damping = config.damping
tolerance = config.tolerance
max_iterations = config.max_iterations

print("=" * 50)
print("BASELINE CONFIGURATION")
print("=" * 50)
print(f"Products (J):           {J}")
print(f"Mean utilities (δ):     {delta}")
print(f"Price sensitivity (α):  {alpha}")
print(f"Marginal costs (c):     {costs}")
print(f"Ownership structure:    Single-product firms (Ω = I)")
print(f"Solver damping (λ):     {damping}")
print(f"Convergence tolerance:  {tolerance}")
```

### Solve Equilibrium

```{python}
#| label: solve

# Solve for Bertrand-Nash equilibrium
result = solve_equilibrium_prices(
    delta=delta,
    alpha=alpha,
    costs=costs,
    ownership=ownership,
    damping=damping,
    tolerance=tolerance,
    max_iterations=max_iterations,
)

print("=" * 50)
print("EQUILIBRIUM SOLUTION")
print("=" * 50)
print(f"Converged:      {result.converged}")
print(f"Iterations:     {result.n_iterations}")
print(f"Final error:    {result.final_error:.2e}")
print()
print("Product-level results:")
print("-" * 50)
print(f"{'Product':<10} {'Price':<12} {'Markup':<12} {'Share':<12}")
print("-" * 50)
for j in range(J):
    print(f"{j:<10} {result.prices[j]:<12.4f} {result.markups[j]:<12.4f} {result.shares[j]:<12.4f}")
print("-" * 50)
print(f"{'Total':<10} {'':<12} {'':<12} {np.sum(result.shares):<12.4f}")
print(f"{'Outside':<10} {'':<12} {'':<12} {1 - np.sum(result.shares):<12.4f}")
```

### Verify Against Analytical Benchmark

```{python}
#| label: verify

# Analytical benchmark: η = 1 / (α * (1 - s))
expected_markups = np.array([
    config.compute_expected_markup(s, alpha) for s in result.shares
])

print("=" * 50)
print("ANALYTICAL BENCHMARK VERIFICATION")
print("=" * 50)
print(f"Formula: η = 1 / (α * (1 - s))")
print()
print(f"{'Product':<10} {'Computed η':<15} {'Expected η':<15} {'Match':<10}")
print("-" * 50)
for j in range(J):
    match = np.isclose(result.markups[j], expected_markups[j], rtol=1e-6)
    print(f"{j:<10} {result.markups[j]:<15.6f} {expected_markups[j]:<15.6f} {'✓' if match else '✗':<10}")

# Verify FOC residuals
Delta = compute_delta(alpha, result.shares)
A = ownership * Delta
foc_residual = result.shares - A @ result.markups
print()
print(f"FOC residual (should be ~0): {np.max(np.abs(foc_residual)):.2e}")
```

## Results

```{python}
#| label: results-summary

# Summary statistics
print("=" * 50)
print("EQUILIBRIUM SUMMARY")
print("=" * 50)
print(f"Average price:          {np.mean(result.prices):.4f}")
print(f"Average markup:         {np.mean(result.markups):.4f}")
print(f"Average margin (%):     {100 * np.mean(result.markups / result.prices):.1f}%")
print(f"Total inside share:     {np.sum(result.shares):.4f}")
print(f"HHI (concentration):    {np.sum(result.shares**2) * 10000:.0f}")
print()

# Pass-through rates
pass_through = np.array([config.compute_pass_through(s) for s in result.shares])
print("Pass-through rates (ρ = 1 - s):")
for j in range(J):
    print(f"  Product {j}: {pass_through[j]:.4f}")
```

## Comparative Statics

```{python}
#| label: comparative-statics
#| fig-cap: "Effect of Price Sensitivity on Equilibrium Outcomes"

# Compute equilibrium for range of alpha values
alpha_range = np.linspace(0.3, 3.0, 50)
markups_alpha = []
prices_alpha = []
shares_alpha = []

for alpha_test in alpha_range:
    res = solve_equilibrium_prices(
        delta=delta, alpha=alpha_test, costs=costs, ownership=ownership
    )
    markups_alpha.append(np.mean(res.markups))
    prices_alpha.append(np.mean(res.prices))
    shares_alpha.append(np.sum(res.shares))

markups_alpha = np.array(markups_alpha)
prices_alpha = np.array(prices_alpha)
shares_alpha = np.array(shares_alpha)

# Create figure with subplots
fig, axes = plt.subplots(1, 3, figsize=(14, 4))

# Panel A: Markup vs Alpha
axes[0].plot(alpha_range, markups_alpha, 'b-', linewidth=2)
axes[0].axhline(y=1/alpha, color='r', linestyle='--', alpha=0.7, label=f'Baseline (α={alpha})')
axes[0].axvline(x=alpha, color='r', linestyle='--', alpha=0.7)
axes[0].set_xlabel('Price Sensitivity (α)')
axes[0].set_ylabel('Average Markup (η)')
axes[0].set_title('A. Markup vs Price Sensitivity')
axes[0].set_xlim(0.3, 3.0)

# Panel B: Price vs Alpha
axes[1].plot(alpha_range, prices_alpha, 'g-', linewidth=2)
axes[1].axhline(y=costs[0], color='gray', linestyle=':', alpha=0.7, label=f'Marginal cost (c={costs[0]})')
axes[1].axvline(x=alpha, color='r', linestyle='--', alpha=0.7)
axes[1].set_xlabel('Price Sensitivity (α)')
axes[1].set_ylabel('Average Price (p)')
axes[1].set_title('B. Price vs Price Sensitivity')
axes[1].set_xlim(0.3, 3.0)
axes[1].legend(loc='upper right')

# Panel C: Total Share vs Alpha
axes[2].plot(alpha_range, shares_alpha, 'm-', linewidth=2)
axes[2].axvline(x=alpha, color='r', linestyle='--', alpha=0.7)
axes[2].set_xlabel('Price Sensitivity (α)')
axes[2].set_ylabel('Total Inside Share')
axes[2].set_title('C. Market Size vs Price Sensitivity')
axes[2].set_xlim(0.3, 3.0)
axes[2].set_ylim(0, 1)

plt.tight_layout()
plt.show()

print("\nInterpretation: Higher α → more elastic demand → lower markups → lower prices → higher market share")
```

```{python}
#| label: comparative-statics-competition
#| fig-cap: "Effect of Number of Competitors on Market Outcomes"

# Compute equilibrium for different number of competitors
J_range = range(1, 21)
markups_J = []
shares_J = []
prices_J = []

for J_test in J_range:
    delta_test = np.ones(J_test)
    costs_test = np.ones(J_test) * 0.5
    ownership_test = np.eye(J_test)
    
    res = solve_equilibrium_prices(
        delta=delta_test, alpha=1.0, costs=costs_test, ownership=ownership_test
    )
    markups_J.append(np.mean(res.markups))
    shares_J.append(res.shares[0])
    prices_J.append(np.mean(res.prices))

markups_J = np.array(markups_J)
shares_J = np.array(shares_J)
prices_J = np.array(prices_J)

# Create figure
fig, axes = plt.subplots(1, 3, figsize=(14, 4))

# Panel A: Markup vs J
axes[0].plot(J_range, markups_J, 'bo-', markersize=5, linewidth=2)
axes[0].axhline(y=1/alpha, color='r', linestyle='--', alpha=0.7, label=f'Competitive limit (1/α = {1/alpha})')
axes[0].set_xlabel('Number of Products (J)')
axes[0].set_ylabel('Average Markup (η)')
axes[0].set_title('A. Markup vs Competition')
axes[0].legend(loc='upper right')
axes[0].set_xlim(0, 21)

# Panel B: Per-product Share vs J
axes[1].plot(J_range, shares_J, 'go-', markersize=5, linewidth=2)
axes[1].set_xlabel('Number of Products (J)')
axes[1].set_ylabel('Per-Product Share (s)')
axes[1].set_title('B. Market Share vs Competition')
axes[1].set_xlim(0, 21)
axes[1].set_ylim(0, 0.5)

# Panel C: Price vs J
axes[2].plot(J_range, prices_J, 'mo-', markersize=5, linewidth=2)
axes[2].axhline(y=0.5, color='gray', linestyle=':', alpha=0.7, label='Marginal cost')
axes[2].axhline(y=0.5 + 1/alpha, color='r', linestyle='--', alpha=0.7, label='Competitive limit')
axes[2].set_xlabel('Number of Products (J)')
axes[2].set_ylabel('Average Price (p)')
axes[2].set_title('C. Price vs Competition')
axes[2].legend(loc='upper right')
axes[2].set_xlim(0, 21)

plt.tight_layout()
plt.show()

print("\nInterpretation: More competitors → lower per-product shares → lower markups → convergence to competitive pricing")
print(f"As J → ∞: markup → 1/α = {1/alpha:.2f}, price → c + 1/α = {0.5 + 1/alpha:.2f}")
```

```{python}
#| label: merger-analysis
#| fig-cap: "Merger Analysis: Effect of Products 0 and 1 Merging"

# Pre-merger: all independent
ownership_pre = np.eye(J)
result_pre = solve_equilibrium_prices(
    delta=delta, alpha=alpha, costs=costs, ownership=ownership_pre
)

# Post-merger: products 0 and 1 merge
ownership_post = np.array([
    [1, 1, 0],
    [1, 1, 0],
    [0, 0, 1],
], dtype=float)
result_post = solve_equilibrium_prices(
    delta=delta, alpha=alpha, costs=costs, ownership=ownership_post, damping=0.5
)

# Create figure
fig, axes = plt.subplots(1, 3, figsize=(14, 5))

# Colors
colors_pre = ['#3498db', '#3498db', '#2ecc71']  # Blue for merging, green for outsider
colors_post = ['#e74c3c', '#e74c3c', '#27ae60']  # Red for merged, darker green for outsider

products = ['Product 0\n(Merging)', 'Product 1\n(Merging)', 'Product 2\n(Outsider)']
x = np.arange(len(products))
width = 0.35

# Panel A: Prices
ax1 = axes[0]
bars1 = ax1.bar(x - width/2, result_pre.prices, width, label='Pre-Merger', color=colors_pre, alpha=0.7, edgecolor='black')
bars2 = ax1.bar(x + width/2, result_post.prices, width, label='Post-Merger', color=colors_post, alpha=0.7, edgecolor='black')
ax1.axhline(y=costs[0], color='gray', linestyle=':', linewidth=2, label=f'Marginal Cost (c={costs[0]})')
ax1.set_ylabel('Price')
ax1.set_title('A. Price Changes from Merger')
ax1.set_xticks(x)
ax1.set_xticklabels(products)
ax1.legend(loc='upper right')
ax1.set_ylim(0, max(result_post.prices) * 1.2)

# Add change annotations
for i, (pre, post) in enumerate(zip(result_pre.prices, result_post.prices)):
    change = post - pre
    ax1.annotate(f'{change:+.3f}', xy=(i + width/2, post + 0.05), ha='center', fontsize=9, color='red' if change > 0 else 'green')

# Panel B: Markups
ax2 = axes[1]
bars3 = ax2.bar(x - width/2, result_pre.markups, width, label='Pre-Merger', color=colors_pre, alpha=0.7, edgecolor='black')
bars4 = ax2.bar(x + width/2, result_post.markups, width, label='Post-Merger', color=colors_post, alpha=0.7, edgecolor='black')
ax2.set_ylabel('Markup (η = p - c)')
ax2.set_title('B. Markup Changes from Merger')
ax2.set_xticks(x)
ax2.set_xticklabels(products)
ax2.legend(loc='upper right')
ax2.set_ylim(0, max(result_post.markups) * 1.2)

# Add change annotations
for i, (pre, post) in enumerate(zip(result_pre.markups, result_post.markups)):
    change = post - pre
    ax2.annotate(f'{change:+.3f}', xy=(i + width/2, post + 0.05), ha='center', fontsize=9, color='red' if change > 0 else 'green')

# Panel C: Market Shares
ax3 = axes[2]
bars5 = ax3.bar(x - width/2, result_pre.shares, width, label='Pre-Merger', color=colors_pre, alpha=0.7, edgecolor='black')
bars6 = ax3.bar(x + width/2, result_post.shares, width, label='Post-Merger', color=colors_post, alpha=0.7, edgecolor='black')
ax3.set_ylabel('Market Share (s)')
ax3.set_title('C. Market Share Changes from Merger')
ax3.set_xticks(x)
ax3.set_xticklabels(products)
ax3.legend(loc='upper right')
ax3.set_ylim(0, max(max(result_pre.shares), max(result_post.shares)) * 1.3)

# Add change annotations
for i, (pre, post) in enumerate(zip(result_pre.shares, result_post.shares)):
    change = post - pre
    ax3.annotate(f'{change:+.3f}', xy=(i + width/2, post + 0.01), ha='center', fontsize=9, color='red' if change > 0 else 'green')

plt.tight_layout()
plt.show()

# Summary table
print("\n" + "=" * 70)
print("MERGER IMPACT SUMMARY")
print("=" * 70)
print(f"\n{'Metric':<25} {'Pre-Merger':<15} {'Post-Merger':<15} {'Change':<15}")
print("-" * 70)
print(f"{'Price (merged firms)':<25} {np.mean(result_pre.prices[:2]):<15.4f} {np.mean(result_post.prices[:2]):<15.4f} {np.mean(result_post.prices[:2]) - np.mean(result_pre.prices[:2]):+.4f}")
print(f"{'Price (outsider)':<25} {result_pre.prices[2]:<15.4f} {result_post.prices[2]:<15.4f} {result_post.prices[2] - result_pre.prices[2]:+.4f}")
print(f"{'Combined share (merged)':<25} {np.sum(result_pre.shares[:2]):<15.4f} {np.sum(result_post.shares[:2]):<15.4f} {np.sum(result_post.shares[:2]) - np.sum(result_pre.shares[:2]):+.4f}")
print(f"{'Share (outsider)':<25} {result_pre.shares[2]:<15.4f} {result_post.shares[2]:<15.4f} {result_post.shares[2] - result_pre.shares[2]:+.4f}")
print(f"{'Outside option share':<25} {1-np.sum(result_pre.shares):<15.4f} {1-np.sum(result_post.shares):<15.4f} {(1-np.sum(result_post.shares)) - (1-np.sum(result_pre.shares)):+.4f}")
print()
print("Interpretation:")
print("• Merged products raise prices → internalize cannibalization effect")
print("• Outsider product also raises price → strategic complement effect")
print("• Consumers shift to outside option → higher prices reduce total demand")
```

## Conclusion

```{python}
#| label: conclusion

print("=" * 50)
print("SOLVER VALIDATION COMPLETE")
print("=" * 50)
print()
print("✓ Equilibrium converged")
print("✓ Markups match analytical formula: η = 1/(α(1-s))")
print("✓ FOC residuals ≈ 0")
print("✓ Comparative statics consistent with theory:")
print("  - Higher α → lower markups")
print("  - More competitors → lower markups")
print("  - Merger → higher prices for merged products")
```
