<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Structural Estimation for Static Oligopoly Pricing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="estimate_opm_files/libs/clipboard/clipboard.min.js"></script>
<script src="estimate_opm_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="estimate_opm_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="estimate_opm_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="estimate_opm_files/libs/quarto-html/popper.min.js"></script>
<script src="estimate_opm_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="estimate_opm_files/libs/quarto-html/anchor.min.js"></script>
<link href="estimate_opm_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="estimate_opm_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="estimate_opm_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="estimate_opm_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="estimate_opm_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#instruction" id="toc-instruction" class="nav-link active" data-scroll-target="#instruction">Instruction</a>
  <ul class="collapse">
  <li><a href="#goal" id="toc-goal" class="nav-link" data-scroll-target="#goal">Goal</a></li>
  <li><a href="#required-components" id="toc-required-components" class="nav-link" data-scroll-target="#required-components">Required Components</a></li>
  <li><a href="#deliverable" id="toc-deliverable" class="nav-link" data-scroll-target="#deliverable">Deliverable</a></li>
  </ul></li>
  <li><a href="#estimation-design" id="toc-estimation-design" class="nav-link" data-scroll-target="#estimation-design">Estimation Design</a>
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#model-structure" id="toc-model-structure" class="nav-link" data-scroll-target="#model-structure">Model Structure</a></li>
  <li><a href="#identification-strategy" id="toc-identification-strategy" class="nav-link" data-scroll-target="#identification-strategy">Identification Strategy</a></li>
  <li><a href="#two-step-estimation-procedure" id="toc-two-step-estimation-procedure" class="nav-link" data-scroll-target="#two-step-estimation-procedure">Two-Step Estimation Procedure</a></li>
  <li><a href="#algorithm-pseudocode" id="toc-algorithm-pseudocode" class="nav-link" data-scroll-target="#algorithm-pseudocode">Algorithm: Pseudocode</a></li>
  <li><a href="#complete-estimation-algorithm" id="toc-complete-estimation-algorithm" class="nav-link" data-scroll-target="#complete-estimation-algorithm">Complete Estimation Algorithm</a></li>
  <li><a href="#diagnostics-and-validation" id="toc-diagnostics-and-validation" class="nav-link" data-scroll-target="#diagnostics-and-validation">Diagnostics and Validation</a></li>
  <li><a href="#outputs" id="toc-outputs" class="nav-link" data-scroll-target="#outputs">Outputs</a></li>
  </ul></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#diagnostics" id="toc-diagnostics" class="nav-link" data-scroll-target="#diagnostics">Diagnostics</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Structural Estimation for Static Oligopoly Pricing</h1>
<p class="subtitle lead">Demand Estimation (GMM) and Cost Recovery</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="instruction" class="level2">
<h2 class="anchored" data-anchor-id="instruction">Instruction</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Original Problem Statement
</div>
</div>
<div class="callout-body-container callout-body">
<p>This section contains the original instructional content defining the estimation exercise.</p>
</div>
</div>
<section id="goal" class="level3">
<h3 class="anchored" data-anchor-id="goal">Goal</h3>
<p>Define the estimation exercise that mirrors <code>scripts/estimate_mdp/estimate_mdp.qmd</code>, but now focuses on recovering demand and cost primitives of the static oligopoly pricing model using the simulated market outcomes generated in <code>scripts/opm/simulate_opm/simulate_opm.qmd</code>.</p>
</section>
<section id="required-components" class="level3">
<h3 class="anchored" data-anchor-id="required-components">Required Components</h3>
<ol type="1">
<li><strong>Data ingestion</strong>: Outline how trainees should load simulated datasets (prices, quantities, instruments, cost shifters) and configuration metadata.</li>
<li><strong>Estimation strategy</strong>: Specify a two-step procedure—(i) back out demand shocks from the share equations and estimate demand parameters using GMM, (ii) back out marginal costs from the first-order conditions and estimate the cost parameters by a regression.</li>
<li><strong>Model validation</strong>: Require fit diagnostics, comparison between recovered and true shocks in demand and cost. The shape of the GMM objective function around the true parameter along each dimension.</li>
</ol>
</section>
<section id="deliverable" class="level3">
<h3 class="anchored" data-anchor-id="deliverable">Deliverable</h3>
<p>An executable Quarto report (to be implemented by juniors) and rendered html report that mirrors the flow of the MDP estimator, but focuses solely on static oligopoly market simulations. Juniors will fill in all code, figures, and tables.</p>
<hr>
</section>
</section>
<section id="estimation-design" class="level2">
<h2 class="anchored" data-anchor-id="estimation-design">Estimation Design</h2>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>The estimation problem is to recover the structural parameters of the oligopoly pricing model from observed market data. We observe:</p>
<ul>
<li><strong>Prices</strong>: <span class="math inline">\(p_{jm}\)</span> for product <span class="math inline">\(j\)</span> in market <span class="math inline">\(m\)</span></li>
<li><strong>Market shares</strong>: <span class="math inline">\(s_{jm}\)</span> for product <span class="math inline">\(j\)</span> in market <span class="math inline">\(m\)</span></li>
<li><strong>Product characteristics</strong>: <span class="math inline">\(\bar{\delta}_j\)</span> (baseline mean utilities)</li>
<li><strong>Cost shifters</strong>: <span class="math inline">\(\bar{c}_j\)</span> (baseline marginal costs)</li>
</ul>
<p>We seek to recover:</p>
<ul>
<li><strong>Demand parameter</strong>: <span class="math inline">\(\alpha\)</span> (price sensitivity)</li>
<li><strong>Demand shocks</strong>: <span class="math inline">\(\xi_{jm}\)</span> (unobserved product quality)</li>
<li><strong>Cost shocks</strong>: <span class="math inline">\(\omega_{jm}\)</span> (unobserved cost variation)</li>
</ul>
</section>
<section id="model-structure" class="level3">
<h3 class="anchored" data-anchor-id="model-structure">Model Structure</h3>
<section id="demand-side" class="level4">
<h4 class="anchored" data-anchor-id="demand-side">Demand Side</h4>
<p>The logit demand model gives market shares: <span class="math display">\[
s_{jm} = \frac{\exp(\delta_{jm} - \alpha p_{jm})}{1 + \sum_{k=1}^{J} \exp(\delta_{km} - \alpha p_{km})}
\]</span></p>
<p>where the mean utility decomposes as: <span class="math display">\[
\delta_{jm} = \bar{\delta}_j + \xi_{jm}
\]</span></p>
<ul>
<li><span class="math inline">\(\bar{\delta}_j\)</span>: baseline mean utility (observed/known from config)</li>
<li><span class="math inline">\(\xi_{jm}\)</span>: demand shock (unobserved, to be recovered)</li>
</ul>
</section>
<section id="supply-side" class="level4">
<h4 class="anchored" data-anchor-id="supply-side">Supply Side</h4>
<p>From profit maximization, the first-order conditions give: <span class="math display">\[
p_{jm} = c_{jm} + \eta_{jm}
\]</span></p>
<p>where: <span class="math display">\[
\eta_{jm} = \frac{1}{\alpha(1 - s_{jm})}
\]</span></p>
<p>Marginal costs decompose as: <span class="math display">\[
c_{jm} = \bar{c}_j + \omega_{jm}
\]</span></p>
<ul>
<li><span class="math inline">\(\bar{c}_j\)</span>: baseline marginal cost (observed/known from config)</li>
<li><span class="math inline">\(\omega_{jm}\)</span>: cost shock (unobserved, to be recovered)</li>
</ul>
</section>
</section>
<section id="identification-strategy" class="level3">
<h3 class="anchored" data-anchor-id="identification-strategy">Identification Strategy</h3>
<section id="the-endogeneity-problem" class="level4">
<h4 class="anchored" data-anchor-id="the-endogeneity-problem">The Endogeneity Problem</h4>
<p>Prices are <strong>endogenous</strong>: firms observe demand shocks <span class="math inline">\(\xi_{jm}\)</span> and set prices accordingly. This creates correlation: <span class="math display">\[
\text{Cov}(p_{jm}, \xi_{jm}) \neq 0
\]</span></p>
<p>Naive regression of shares on prices yields biased estimates of <span class="math inline">\(\alpha\)</span>.</p>
</section>
<section id="instrumental-variables" class="level4">
<h4 class="anchored" data-anchor-id="instrumental-variables">Instrumental Variables</h4>
<p>We need instruments <span class="math inline">\(Z_{jm}\)</span> that satisfy:</p>
<ol type="1">
<li><strong>Relevance</strong>: <span class="math inline">\(\text{Cov}(Z_{jm}, p_{jm}) \neq 0\)</span></li>
<li><strong>Exogeneity</strong>: <span class="math inline">\(\text{Cov}(Z_{jm}, \xi_{jm}) = 0\)</span></li>
</ol>
<p><strong>BLP-style instruments</strong> (characteristics of competing products):</p>
<ul>
<li>Sum of competitors’ characteristics: <span class="math inline">\(Z_{jm}^{BLP} = \sum_{k \neq j} x_{km}\)</span></li>
<li>Rationale: Other products’ characteristics affect equilibrium prices (relevance) but are uncorrelated with own demand shocks (exogeneity)</li>
</ul>
<p><strong>Cost shifters</strong> (excluded from demand):</p>
<ul>
<li>Variables that affect costs but not utility directly</li>
<li>E.g., input prices, distance to suppliers</li>
</ul>
</section>
<section id="our-setting-simulation" class="level4">
<h4 class="anchored" data-anchor-id="our-setting-simulation">Our Setting (Simulation)</h4>
<p>In our simulation:</p>
<ul>
<li>We <strong>know</strong> the true <span class="math inline">\(\alpha\)</span> (can verify recovery)</li>
<li>We <strong>know</strong> the true shocks <span class="math inline">\(\xi_{jm}, \omega_{jm}\)</span> (can validate)</li>
<li>Cost shocks <span class="math inline">\(\omega_{jm}\)</span> serve as natural instruments (affect prices, uncorrelated with demand shocks by construction)</li>
</ul>
</section>
</section>
<section id="two-step-estimation-procedure" class="level3">
<h3 class="anchored" data-anchor-id="two-step-estimation-procedure">Two-Step Estimation Procedure</h3>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                   TWO-STEP ESTIMATION                           │
├─────────────────────────────────────────────────────────────────┤
│  STEP 1: Demand Estimation (GMM)                                │
│          • Berry inversion: recover δ from shares               │
│          • Compute demand shocks: ξ = δ - δ̄                     │
│          • GMM: find α that makes E[Z'ξ] = 0                    │
├─────────────────────────────────────────────────────────────────┤
│  STEP 2: Cost Recovery                                          │
│          • Use estimated α̂ to compute markups                   │
│          • Back out costs: c = p - η                            │
│          • Recover cost shocks: ω = c - c̄                       │
└─────────────────────────────────────────────────────────────────┘</code></pre>
</section>
<section id="algorithm-pseudocode" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-pseudocode">Algorithm: Pseudocode</h3>
<section id="step-1-berry-inversion" class="level4">
<h4 class="anchored" data-anchor-id="step-1-berry-inversion">Step 1: Berry Inversion</h4>
<pre><code>FUNCTION BERRY_INVERSION(shares, outside_share):
    """
    Invert market shares to recover mean utilities.
    
    For logit demand without random coefficients:
        ln(s_j) - ln(s_0) = δ_j - α*p_j
    
    Since we want δ_j (including the -αp term absorbed):
        δ_j = ln(s_j) - ln(s_0)
    
    This is the "observed" mean utility that rationalizes shares.
    """
    
    INPUT:
      shares       : Matrix[M, J]    # Market shares s_jm
      outside_share: Vector[M]       # Outside option share s_0m = 1 - Σ_j s_jm
    
    OUTPUT:
      delta        : Matrix[M, J]    # Mean utilities δ_jm
    
    PROCEDURE:
      FOR m = 1 TO M:
        s_0m = outside_share[m]
        FOR j = 1 TO J:
          delta[m, j] = ln(shares[m, j]) - ln(s_0m)
      
      RETURN delta</code></pre>
</section>
<section id="step-1-gmm-estimation-of-α" class="level4">
<h4 class="anchored" data-anchor-id="step-1-gmm-estimation-of-α">Step 1: GMM Estimation of α</h4>
<pre><code>FUNCTION ESTIMATE_ALPHA_GMM(prices, shares, delta_bar, instruments):
    """
    Estimate price sensitivity α via GMM.
    
    Model: δ_jm = δ̄_j + ξ_jm  (mean utility)
           δ_jm^obs = ln(s_jm) - ln(s_0m) = δ̄_j - α*p_jm + ξ_jm
    
    Rearranging:
           ξ_jm = δ_jm^obs - δ̄_j + α*p_jm
    
    Moment condition: E[Z_jm * ξ_jm] = 0
    
    GMM objective: Q(α) = ξ(α)' Z (Z'Z)^{-1} Z' ξ(α)
    """
    
    INPUT:
      prices     : Matrix[M, J]    # Observed prices p_jm
      shares     : Matrix[M, J]    # Observed shares s_jm
      delta_bar  : Vector[J]       # Baseline mean utilities δ̄_j
      instruments: Matrix[M*J, K]  # Instruments Z
    
    OUTPUT:
      alpha_hat  : Scalar          # Estimated price sensitivity
      xi_hat     : Matrix[M, J]    # Recovered demand shocks
    
    PROCEDURE:
      # Berry inversion
      outside_share = 1 - sum(shares, axis=1)
      delta_obs = BERRY_INVERSION(shares, outside_share)
      
      # GMM objective function
      FUNCTION gmm_objective(alpha):
        # Compute demand shocks
        xi = delta_obs - delta_bar + alpha * prices
        xi_vec = xi.flatten()
        
        # Moment conditions
        moments = Z' * xi_vec
        
        # GMM criterion (2-step efficient: W = (Z'Z)^{-1})
        W = inv(Z' * Z)
        Q = moments' * W * moments
        
        RETURN Q
      
      # Minimize GMM objective
      alpha_hat = argmin_{alpha} gmm_objective(alpha)
      
      # Recover demand shocks at estimated α
      xi_hat = delta_obs - delta_bar + alpha_hat * prices
      
      RETURN alpha_hat, xi_hat</code></pre>
</section>
<section id="step-2-cost-recovery" class="level4">
<h4 class="anchored" data-anchor-id="step-2-cost-recovery">Step 2: Cost Recovery</h4>
<pre><code>FUNCTION RECOVER_COSTS(prices, shares, alpha_hat, costs_bar, ownership):
    """
    Back out marginal costs from FOC.
    
    FOC: p_j = c_j + η_j
    where η_j = 1/(α(1-s_j)) for single-product firms
    
    Therefore: c_j = p_j - η_j
    Cost shock: ω_j = c_j - c̄_j
    """
    
    INPUT:
      prices    : Matrix[M, J]    # Observed prices
      shares    : Matrix[M, J]    # Observed shares
      alpha_hat : Scalar          # Estimated α
      costs_bar : Vector[J]       # Baseline costs c̄_j
      ownership : Matrix[J, J]    # Ownership matrix Ω
    
    OUTPUT:
      costs_hat : Matrix[M, J]    # Recovered marginal costs
      omega_hat : Matrix[M, J]    # Recovered cost shocks
      markups   : Matrix[M, J]    # Implied markups
    
    PROCEDURE:
      FOR m = 1 TO M:
        # Compute markups from FOC
        FOR j = 1 TO J:
          markups[m, j] = 1 / (alpha_hat * (1 - shares[m, j]))
        
        # Back out costs
        costs_hat[m] = prices[m] - markups[m]
        
        # Recover cost shocks
        omega_hat[m] = costs_hat[m] - costs_bar
      
      RETURN costs_hat, omega_hat, markups</code></pre>
</section>
</section>
<section id="complete-estimation-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="complete-estimation-algorithm">Complete Estimation Algorithm</h3>
<pre><code>ALGORITHM: ESTIMATE_OPM
────────────────────────
INPUT:
  prices     : Matrix[M, J]    # Observed equilibrium prices
  shares     : Matrix[M, J]    # Observed market shares
  delta_bar  : Vector[J]       # Baseline mean utilities (from config)
  costs_bar  : Vector[J]       # Baseline marginal costs (from config)
  ownership  : Matrix[J, J]    # Ownership structure (from config)
  instruments: Matrix[M*J, K]  # Instruments for GMM

OUTPUT:
  EstimationResult containing:
    - alpha_hat : Scalar         # Estimated price sensitivity
    - xi_hat    : Matrix[M, J]   # Recovered demand shocks
    - omega_hat : Matrix[M, J]   # Recovered cost shocks
    - costs_hat : Matrix[M, J]   # Recovered marginal costs

PROCEDURE:
  # ─────────────────────────────────────────────
  # STEP 1: DEMAND ESTIMATION (GMM)
  # ─────────────────────────────────────────────
  
  # 1a. Berry inversion
  outside_share = 1 - rowsum(shares)
  delta_obs = ln(shares) - ln(outside_share)  # element-wise
  
  # 1b. GMM estimation
  alpha_hat, xi_hat = ESTIMATE_ALPHA_GMM(
      prices, shares, delta_bar, instruments
  )
  
  # ─────────────────────────────────────────────
  # STEP 2: COST RECOVERY
  # ─────────────────────────────────────────────
  
  costs_hat, omega_hat, markups = RECOVER_COSTS(
      prices, shares, alpha_hat, costs_bar, ownership
  )
  
  RETURN EstimationResult(alpha_hat, xi_hat, omega_hat, costs_hat)</code></pre>
</section>
<section id="diagnostics-and-validation" class="level3">
<h3 class="anchored" data-anchor-id="diagnostics-and-validation">Diagnostics and Validation</h3>
<section id="parameter-recovery" class="level4">
<h4 class="anchored" data-anchor-id="parameter-recovery">Parameter Recovery</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Check</th>
<th>Description</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>α recovery</td>
<td>Compare <span class="math inline">\(\hat{\alpha}\)</span> to true <span class="math inline">\(\alpha\)</span></td>
<td>Bias &lt; 5%</td>
</tr>
<tr class="even">
<td>Standard error</td>
<td>Asymptotic SE from GMM</td>
<td>Covers true value</td>
</tr>
</tbody>
</table>
</section>
<section id="shock-recovery" class="level4">
<h4 class="anchored" data-anchor-id="shock-recovery">Shock Recovery</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 43%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Check</th>
<th>Description</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Demand shocks</td>
<td>Correlation(<span class="math inline">\(\hat{\xi}\)</span>, true <span class="math inline">\(\xi\)</span>)</td>
<td>&gt; 0.95</td>
</tr>
<tr class="even">
<td>Cost shocks</td>
<td>Correlation(<span class="math inline">\(\hat{\omega}\)</span>, true <span class="math inline">\(\omega\)</span>)</td>
<td>&gt; 0.99</td>
</tr>
<tr class="odd">
<td>Mean recovery</td>
<td>Mean(<span class="math inline">\(\hat{\xi}\)</span>) ≈ 0, Mean(<span class="math inline">\(\hat{\omega}\)</span>) ≈ 0</td>
<td>Near zero</td>
</tr>
</tbody>
</table>
</section>
<section id="gmm-diagnostics" class="level4">
<h4 class="anchored" data-anchor-id="gmm-diagnostics">GMM Diagnostics</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 43%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Check</th>
<th>Description</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>J-statistic</td>
<td>Overidentification test</td>
<td>p &gt; 0.05</td>
</tr>
<tr class="even">
<td>Objective surface</td>
<td>GMM objective around <span class="math inline">\(\hat{\alpha}\)</span></td>
<td>Clear minimum</td>
</tr>
<tr class="odd">
<td>First-stage F</td>
<td>Instrument strength</td>
<td>F &gt; 10</td>
</tr>
</tbody>
</table>
</section>
<section id="economic-validity" class="level4">
<h4 class="anchored" data-anchor-id="economic-validity">Economic Validity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Check</th>
<th>Description</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Markups positive</td>
<td>All <span class="math inline">\(\hat{\eta}_{jm} &gt; 0\)</span></td>
<td>✓</td>
</tr>
<tr class="even">
<td>Costs positive</td>
<td>All <span class="math inline">\(\hat{c}_{jm} &gt; 0\)</span></td>
<td>✓</td>
</tr>
<tr class="odd">
<td>FOC satisfied</td>
<td><span class="math inline">\(p = c + \eta\)</span> holds</td>
<td>✓</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="outputs" class="level3">
<h3 class="anchored" data-anchor-id="outputs">Outputs</h3>
<p>The estimator produces:</p>
<ol type="1">
<li><strong>Parameter estimates</strong>: <span class="math inline">\(\hat{\alpha}\)</span> with standard errors</li>
<li><strong>Recovered shocks</strong>: <span class="math inline">\(\hat{\xi}_{jm}\)</span>, <span class="math inline">\(\hat{\omega}_{jm}\)</span> for all markets</li>
<li><strong>Implied costs</strong>: <span class="math inline">\(\hat{c}_{jm}\)</span> for all markets</li>
<li><strong>Diagnostics</strong>: GMM objective, J-statistic, correlation with true values</li>
</ol>
<hr>
</section>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p><em>To be implemented: Setup, data loading, estimation, results, diagnostics.</em></p>
<hr>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p><em>To be implemented: Parameter estimates, shock recovery, validation tables.</em></p>
<hr>
</section>
<section id="diagnostics" class="level2">
<h2 class="anchored" data-anchor-id="diagnostics">Diagnostics</h2>
<p><em>To be implemented: GMM objective surface, shock correlations, economic checks.</em></p>
<hr>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p><em>To be implemented: Summary of findings, comparison to true parameters.</em></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>