---
title: "Solving a Static Oligopoly Pricing Model"
subtitle: "Bertrand Competition with Differentiated Products"
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
---

## Instruction

**Goal**: Replicate the structure of `scripts/solve_mdp/solve_mdp.qmd`, but replace the Markov Decision Process with a **static oligopoly pricing model** in which multiple firms set prices simultaneously to maximize period profits. The objective is to design and document a solver that:

- Specifies firm demand (e.g., logit demand with market share as a function of own price and rivals' prices)
- Defines marginal costs and strategic interaction assumptions (Bertrand competition with differentiated products)
- Derives the Nash equilibrium first-order conditions for optimal prices
- Implements a numerical fixed-point or contraction mapping routine that solves for equilibrium prices and markups under the chosen demand system

**Required Components**:

1. **Model primitives**: Demand parameters, cost structure, number of firms/products, and any demand and cost shifters.
2. **Equilibrium algorithm**: Specify how to numerically solve the nonlinear system of first-order conditions (FOCs) characterizing the static Nash equilibrium in prices.
3. **Verification plan**: Outline how juniors should validate convergence (e.g., norm of FOC residuals, comparison to analytical benchmarks in symmetric cases).
4. **Documentation**: Describe expected figures/tables (e.g., comparative statics over demand elasticities, passthrough analyses) without implementing them.

**Deliverable**: An executable Quarto report and rendered html report that mirrors the MDP solver report while focusing entirely on the static oligopoly pricing equilibrium problem.

---

## Model Setup

We consider a static oligopoly pricing model with:

- **Products**: $J$ differentiated products indexed by $j = 1, \ldots, J$, plus an outside option $j = 0$
- **Firms**: $F$ firms, where firm $f$ owns a subset of products $\mathcal{J}_f \subseteq \{1, \ldots, J\}$
- **Market size**: Normalized to $M = 1$ (equilibrium prices are independent of market size)
- **Competition**: Bertrand (simultaneous price setting)

### Demand: Logit Model

Consumer $i$'s indirect utility from product $j$ is:
$$
u_{ij} = \delta_j - \alpha p_j + \varepsilon_{ij}
$$

where:

- $\delta_j$ = mean utility of product $j$ (captures quality, characteristics)
- $\alpha > 0$ = price sensitivity coefficient
- $p_j$ = price of product $j$
- $\varepsilon_{ij} \sim$ Type-I Extreme Value (iid across consumers and products)

The outside option provides utility $u_{i0} = \varepsilon_{i0}$ (normalized to zero mean utility).

### Market Shares

Under the logit assumption, the market share of product $j$ is:
$$
s_j(p) = \frac{\exp(\delta_j - \alpha p_j)}{1 + \sum_{k=1}^{J} \exp(\delta_k - \alpha p_k)}
$$

The outside option share is:
$$
s_0(p) = \frac{1}{1 + \sum_{k=1}^{J} \exp(\delta_k - \alpha p_k)}
$$

### Cost Structure

Each product $j$ has constant marginal cost $c_j$. Firm $f$'s profit is:
$$
\pi_f(p) = \sum_{j \in \mathcal{J}_f} (p_j - c_j) \cdot s_j(p)
$$

## Equilibrium Conditions

### Bertrand-Nash Equilibrium

In a Bertrand-Nash equilibrium, each firm $f$ chooses prices for its products to maximize profit, taking rivals' prices as given:
$$
\max_{\{p_j\}_{j \in \mathcal{J}_f}} \sum_{j \in \mathcal{J}_f} (p_j - c_j) \cdot s_j(p)
$$

### First-Order Conditions

The FOC for product $j$ owned by firm $f$ is:
$$
\frac{\partial \pi_f}{\partial p_j} = s_j + \sum_{k \in \mathcal{J}_f} (p_k - c_k) \cdot \frac{\partial s_k}{\partial p_j} = 0
$$

### Logit Share Derivatives

For the logit model, the share derivatives have closed-form expressions:

**Own-price effect** (negative):
$$
\frac{\partial s_j}{\partial p_j} = -\alpha s_j (1 - s_j)
$$

**Cross-price effect** (positive, for $k \neq j$):
$$
\frac{\partial s_k}{\partial p_j} = \alpha s_k s_j
$$

### Matrix Formulation

Define the following matrices:

- **Ownership matrix** $\Omega$: $\Omega_{jk} = 1$ if products $j$ and $k$ are owned by the same firm, $0$ otherwise
- **Share derivative matrix** $\Delta$: $\Delta_{jk} = -\frac{\partial s_j}{\partial p_k}$

For logit demand:
$$
\Delta_{jk} = \begin{cases}
\alpha s_j (1 - s_j) & \text{if } j = k \\
-\alpha s_j s_k & \text{if } j \neq k
\end{cases}
$$

### Markup Equation

The system of FOCs can be written compactly as:
$$
s + (\Omega \odot \Delta)(p - c) = 0
$$

where $\odot$ denotes element-wise (Hadamard) product.

Solving for the equilibrium markup:
$$
p - c = -(\Omega \odot \Delta)^{-1} s
$$

This is the **markup equation**: equilibrium prices equal marginal cost plus a markup that depends on:

1. **Market shares** $s$ — higher shares imply more market power
2. **Price sensitivity** $\alpha$ — higher sensitivity reduces markups
3. **Ownership structure** $\Omega$ — multi-product firms internalize cannibalization

## Analytical Benchmarks

### Single-Product Firms

When each firm owns exactly one product ($\Omega = I$), the FOC for product $j$ simplifies to:
$$
s_j - \alpha s_j (1 - s_j) \eta_j = 0
$$

Solving for the markup:
$$
\eta_j = \frac{1}{\alpha (1 - s_j)}
$$

**Interpretation**: Markup is inversely proportional to:

- Price sensitivity $\alpha$
- "Competitive pressure" $(1 - s_j)$ = probability of losing customer to other products

### Symmetric Equilibrium

For identical products ($\delta_j = \delta$, $c_j = c$ for all $j$) with single-product firms, the symmetric equilibrium has $s_j = s$ for all $j$:
$$
s = \frac{\exp(\delta - \alpha p)}{1 + J \exp(\delta - \alpha p)}
$$

With markup $\eta = \frac{1}{\alpha(1-s)}$.

As $J \to \infty$: $s \to 0$, so $\eta \to \frac{1}{\alpha}$ (competitive limit).

### Comparative Statics

| Parameter | Change | Effect on Markup $\eta$ | Effect on Price $p$ | Intuition |
|-----------|--------|-------------------------|---------------------|-----------|
| $\alpha$ ↑ | More price sensitive | $\eta$ ↓ | $p$ ↓ | Elastic demand → less market power |
| $\delta_j$ ↑ | Higher quality | $\eta_j$ ↑ | $p_j$ ↑ | Higher $s_j$ → more inelastic residual demand |
| $c_j$ ↑ | Higher cost | — | $p_j$ ↑ | Cost pass-through |
| $J$ ↑ | More competitors | $\eta$ ↓ | $p$ ↓ | Lower shares → more competition |
| Merger | $\Omega_{jk}: 0 \to 1$ | $\eta_j, \eta_k$ ↑ | $p_j, p_k$ ↑ | Internalize cannibalization |

### Cost Pass-Through

For single-product firms with logit demand, the pass-through rate measures how much of a cost increase is passed to consumers:
$$
\rho_j = \frac{\partial p_j}{\partial c_j}
$$

Differentiating the equilibrium condition yields:
$$
\rho_j = \frac{1}{1 + \alpha s_j \eta_j}
$$

Substituting $\eta_j = \frac{1}{\alpha(1-s_j)}$:
$$
\rho_j = \frac{1}{1 + \frac{s_j}{1-s_j}} = 1 - s_j
$$

**Result**: Pass-through $\rho_j = 1 - s_j < 1$.

**Interpretation**:

- Firms with **higher market share** absorb more of cost increases ($\rho_j$ lower)
- Firms with **lower market share** pass through more to consumers ($\rho_j$ closer to 1)
- In the competitive limit ($s_j \to 0$): $\rho_j \to 1$ (full pass-through)

## Solution Method

### Fixed-Point Iteration on Markups

The markup equation defines a fixed-point problem. Define the markup $\eta_j = p_j - c_j$. Given prices $p = c + \eta$, the equilibrium markup satisfies:
$$
\eta = -(\Omega \odot \Delta(c + \eta))^{-1} s(c + \eta)
$$

This suggests the **fixed-point iteration**:
$$
\eta^{(k+1)} = -(\Omega \odot \Delta(p^{(k)}))^{-1} s(p^{(k)})
$$
where $p^{(k)} = c + \eta^{(k)}$.

### Damped Iteration

For stability, we use **damping** (convex combination of old and new):
$$
\eta^{(k+1)} = (1 - \lambda) \eta^{(k)} + \lambda \left[ -(\Omega \odot \Delta(p^{(k)}))^{-1} s(p^{(k)}) \right]
$$
where $\lambda \in (0, 1]$ is the damping factor. Smaller $\lambda$ improves stability at the cost of slower convergence.

### Convergence Criterion

Iterate until the markup change is small:
$$
\| \eta^{(k+1)} - \eta^{(k)} \|_\infty < \varepsilon
$$

### Type Definitions

```
TYPE DEFINITIONS
────────────────
Scalar      = Float                      # Single real number
Vector[J]   = Array[Float, J]            # 1D array of J floats
Matrix[J,J] = Array[Float, J, J]         # 2D array of shape (J, J)
```

### Algorithm

```
ALGORITHM: SOLVE_EQUILIBRIUM_PRICES
───────────────────────────────────
INPUT:
  δ            : Vector[J]       # Mean utilities
  α            : Scalar          # Price sensitivity
  c            : Vector[J]       # Marginal costs
  Ω            : Matrix[J,J]     # Ownership matrix
  λ            : Scalar          # Damping factor (default: 1.0)
  ε            : Scalar          # Convergence tolerance
  K            : Int             # Maximum iterations

OUTPUT:
  p            : Vector[J]       # Equilibrium prices
  η            : Vector[J]       # Equilibrium markups
  s            : Vector[J]       # Equilibrium market shares
  converged    : Bool            # Convergence flag

PROCEDURE:
  # Initialize markups (start from marginal cost pricing)
  η : Vector[J] ← zeros(J)
  
  FOR k = 1 TO K:
    # Current prices
    p : Vector[J] ← c + η
    
    # Compute market shares
    s : Vector[J] ← COMPUTE_SHARES(δ, α, p)
    
    # Compute share derivative matrix
    Δ : Matrix[J,J] ← COMPUTE_DELTA(α, s)
    
    # Compute new markups from FOC
    η_new : Vector[J] ← SOLVE_MARKUP_EQUATION(Ω, Δ, s)
    
    # Damped update
    η_update : Vector[J] ← (1 - λ) * η + λ * η_new
    
    # Check convergence
    IF max(|η_update - η|) < ε:
      η ← η_update
      p ← c + η
      s ← COMPUTE_SHARES(δ, α, p)
      RETURN (p, η, s, converged=True)
    
    η ← η_update
  
  # Did not converge
  p ← c + η
  s ← COMPUTE_SHARES(δ, α, p)
  RETURN (p, η, s, converged=False)
```

### Subroutines

```
SUBROUTINE: COMPUTE_SHARES
──────────────────────────
INPUT:
  δ      : Vector[J]             # Mean utilities
  α      : Scalar                # Price sensitivity
  p      : Vector[J]             # Prices
OUTPUT:
  s      : Vector[J]             # Market shares

  # Compute mean utilities net of price
  v : Vector[J] ← δ - α * p
  
  # Numerically stable softmax
  v_max : Scalar ← max(v)
  exp_v : Vector[J] ← exp(v - v_max)
  denom : Scalar ← exp(-v_max) + sum(exp_v)
  
  s : Vector[J] ← exp_v / denom
  RETURN s
```

```
SUBROUTINE: COMPUTE_DELTA
─────────────────────────
INPUT:
  α      : Scalar                # Price sensitivity
  s      : Vector[J]             # Market shares
OUTPUT:
  Δ      : Matrix[J,J]           # Share derivative matrix

  # Δ_jk = -∂s_j/∂p_k
  FOR j = 1 TO J:
    FOR k = 1 TO J:
      IF j = k:
        Δ[j,k] ← α * s[j] * (1 - s[j])    # Own-price
      ELSE:
        Δ[j,k] ← -α * s[j] * s[k]          # Cross-price
  
  RETURN Δ
```

```
SUBROUTINE: SOLVE_MARKUP_EQUATION
─────────────────────────────────
INPUT:
  Ω      : Matrix[J,J]           # Ownership matrix
  Δ      : Matrix[J,J]           # Share derivative matrix
  s      : Vector[J]             # Market shares
OUTPUT:
  η      : Vector[J]             # Markups

  # Compute Ω ⊙ Δ (element-wise product)
  A : Matrix[J,J] ← Ω ⊙ Δ
  
  # Solve linear system: A * η = -s
  η : Vector[J] ← SOLVE_LINEAR_SYSTEM(A, -s)
  
  RETURN η
```

### Convergence Properties

The fixed-point iteration converges when the mapping is a **contraction**. Key factors affecting convergence:

1. **Price sensitivity $\alpha$**: Higher $\alpha$ → more elastic demand → smaller markups → faster convergence
2. **Market concentration**: More products owned by same firm → larger markups → slower convergence
3. **Damping $\lambda$**: Smaller $\lambda$ → more stable but slower

### Verification Plan

To validate the solver:

1. **FOC residuals**: Check $\| s + (\Omega \odot \Delta)(p - c) \|_\infty < \varepsilon$
2. **Symmetric benchmark**: For symmetric products with single-product firms, verify $\eta_j = \frac{1}{\alpha(1 - s_j)}$
3. **Monopoly benchmark**: Single firm owning all products should yield monopoly prices
4. **Comparative statics**: Higher $\alpha$ → lower markups; merger (change $\Omega$) → higher markups

## Implementation

### Setup

```{python}
#| label: setup
#| cache: false

# Standard libraries
import sys
import numpy as np

# Add project paths
sys.path.insert(0, "../../../src")
sys.path.insert(0, "../config_opm")
sys.path.insert(0, "../../utils")

print("Modules loaded successfully")
```

### Model Parameters

```{python}
#| label: parameters

# Parameters will be loaded from config_opm/config.py
# For now, placeholder
print("Parameters to be loaded from config")
```

### Solve Equilibrium

```{python}
#| label: solve

# Solver implementation will go here
print("Solver to be implemented")
```

## Results

*(To be filled: equilibrium prices, markups, market shares)*

## Comparative Statics

*(To be filled: effects of varying demand elasticity, costs, etc.)*

## Conclusion

*(To be filled: interpretation of results)*
